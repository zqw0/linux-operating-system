## 杂项  
（1）程序运行起来的虚拟地址都是从1开始的。只不过每个程序维护的页表不一样。所以他们映射的物理内存也不一样。  
（2）dll动态加载，用时才加载到内存。  
（3）对于虚拟地址上的堆，也是连续的。那么不停的new，delete就会产生内存碎片。那么申请固定内存，就显得额外重要。  
（4）外部碎片：比如在堆上， 不断的申请释放，就会出现小夹缝。导致这块小夹缝谁都用不了，因为太小了。这就叫外部碎片。  
（5）内部碎片：我申请了3k内存，给我了4k，我申请了4k内存，给了我4k。我申请了4k+1内存，给了我8k。给的我多余的内存就叫做内部碎片。  
（6）逻辑地址的不连续：因为在逻辑地址上，又给你划分了许多段（**这就是段式管理**），有的段存代码段，有的段作为栈，有的段作为堆。有的段什么也不做，什么也不做的段如果被访问到了。那么就会出现段错误。  
（7）物理页面要和逻辑页面保持一致。  
（8）逻辑地址的寻址：假如，你的**逻辑地址为32位，页大小为4k（代表有2^12个页表项，也就是真正存放物理内存地址的地方）**。假如我有一个逻辑地址为：  
00000000 00000000 00000000 00000110这样一个为6的逻辑地址。首先后**12个位也就是00 00000110，代表第几个页表项**。而前**20个位代表第几个逻辑页表，有了逻辑页表，再通过一个哈希表（页表）对应出第几个物理页表**。最后将**物理页表与逻辑页表进行拼接，得到真正的物理地址**。  
（9）页表存放在寄存器中。  
（10）TLB（快表）将热的数据存储到快表之中，这个快表也是哈希的结构。但是硬件对快表有并行搜索。结果会非常快。每次先去快表上搜，搜不到再去页表中搜索结果。  
（11）内存保护，有的内存虽然拥有，但是当只读的时候，是不能够修改的。  
（12）两级页表结构：原本**页表的项数为2^20个项数，一个页表项的大小为4字节，一个页表大小为4mb**，现在将页表拆成**2^10+2^10个项数，一个页表项大小为4字节。现在一个页表大小为8k**。    
（13）**缺页错误**：页表中有一个位代表有效无效位，如果是有效位，那么这物理地址就在内存中。如果是无效位，那么先判断是否在外存中，如果不在外存。那么就会段错误。如果存在就把该外存的一页拿到内存中。    
（14）LRU，最近最少使用算法。假如物理页只有4页。现在有如下页号。1,2,3,4,1,2,5,1,2,3,4,5。第一次为1,2,3,4。第二次为1,2,5,4。第三次为1,2,5,3。第四次为1,2,4,3。第5次为5,2,4,3。
（15）页面缓冲，就像内存池，当有程序需要页面是。操作系统就从页面缓冲中拿出一个页面给程序用。    
（16）抖动：页面频繁的换入换出。    
（17）如何减少缺页？：局部工作性原理。用一些操作比较频繁的页面。来减少页面的换入换出。  
（18）工作集：就是程序最近访问的页面的集合。  
（19）mmap()，功能打开一个文件，却能像访问内存一样访问此文件。对此文件进行改写，读。速度非常快。如何实现？就是利用了虚拟内存的方法。**首先将此文件,从硬盘上，读到物理内存中。然后通过改写程序的页表。使程序能够访问这块物理内存。当你进行修改后，那么有的页被修改，就将它写回到文件中。有的页没被修改，就直接丢弃掉**。还有一个用处就是内存的共享。**当两个程序同时用mmap打开一个文件，相当于映射到了同一片内存区域。这样就实现了内存的共享**。  
（20）一个程序：
```
for(int i = 0; i < 1024; i++){
        for(int j = 0; j < 1024; j++)
                dp[i][j] = 0;
for(int i = 0; i < 1024; i++){
        for(int j = 0; j < 1024; j++)
                dp[j][i] = 0;                
 差别在于工作集的大小。局部性小，那么页的换入换出，就非常少。反之非常大。
```
（21）堆的局部性不如栈的局部性原理。因为栈是从下往上增长的。是连续分配的。而堆分配空间，是随机的。所以堆的局部性比栈的局部性差。缺页错会变多。  


## 页  
**介绍**：内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字节，但是，内存管理单元（MMU，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，MMU以页大小为单位来管理系统中的页表。从虚拟内存的角度来看，页就是最小单位。    
内核用struct page结构来标识系统中的每个物理页。
```
struct page{
        unsigned long                   flags;
        atomic_t                              _count;
        atomic_t                              _mapcount;
        unsigned long                   private;
        struct address_space     *mapping;
        pgoff_t                                   index;
        struct list_head                  lru;
        void                                          *virtual;
};
```
**属性解释**：  
flag：用来存放页的状态。状态包括页是不是脏的，是不是被锁在内存中等等。  
count：存放页的引用计数-------也就是这一页被引用了多少此。当引用计数变为-1时，就说明当前内核并没有引用这一页。但是内核代码不应该直接检查该域。应该调用page_count()函数来进行检查。该函数唯一参数就是page结构。**当页空闲时，尽管该结构内部的count值是负数，但是对page_count()函数而言，返回0标示页空闲，返回一个正整数表示页在使用**。    
virtual：是页的虚拟地址。通常情况下他就是页在虚拟内存中的地址。有些内存（即所谓的高端内存）并不永久的映射到内核地址空间上。  
## 区  
由于硬件的限制，内核并不能对所有的页一视同仁。有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区。linux必须处理如下两种由于硬件存在缺陷而引起的内存寻址问题。  
一些硬件只能用于某些特定的内存地址来执行DMA（直接内存访问）。  
一些体系结构的内存的物理寻址范围比虚拟寻址范围大的多。这样，就有一些内存不能永久的映射到内核空间上。  
因为这个条件，linux主要包含了四种区：    
ZONE_DMA：这个区包含的页能用来执行DMA操作。  
ZONE_DMA32：和ZONE_DMA类似，该区包含的页面可用来执行DMA操作。而和ZONE_DMA不同之处在于，这些页面只能被32位设备访问。  
ZONE_NORMAL：这个区包含的都是能正常映射的页。    
ZONE_HIGHEM：这个区包含“高端内存”，其中的页并不能永久的映射到内核地址空间。   
## 申请页  
```
struct page * alloc_pages(gfp_t gfp_mask, unsigned int order)
该函数分配1<<order个连续物理页，并返回一个指针，该指针指向第一个页的page结构体。如果出错就返回NULL。
```
上述函数只能得到结构体。需要用下面函数将其转换为它的逻辑地址。  
```
void * page_address(struct page *page)
返回一个指针，指向给定物理页当前所在的逻辑地址。
```
列出一些获取页的api
```
unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)//此函数与alloc_pages作用相同，不过它直接返回请求的第一个页的逻辑地址。

struct page * alloc_page(gfp_t gfp_mask)
unsigned long __get_free_page(gfp_t gfp_mask)//这两个函数与其兄弟函数工作方式相同，不过只申请一页。order = 0,1<<order。

unsigned long get_zeroed_page(unsigned int gfp_mask)//将获取的页的内容全部置为0再返回，逻辑地址。
```
## 释放页
列出释放页的一些api
```
void __free_pages(struct page *page, unsigned int order);
void free_pages(unsigned long addr, unsigned int order);
void free_page(unsigned long addr);
```
## kmalloc()
**意义**：在于申请的物理页连续，局部性原理好。缺页错少。  
```
void * kmalloc(size_t size, gfp_t flags);
功能，可以获得以字节为单位的一块内核内存。
示例
int * ptr = kmalloc(4, GFP_KERNEL);
如果返回NULL代表内存不足。
```
## gfp_mask标志  
标志可以分为三类：行为修饰符，区修饰符，及类型。    
（1）行为修饰符标识内核应当如何分配所需的内存。例如中断处理程序就要求内核在分配内存的过程中不能睡眠。    
（2）区修饰符指明到底从这些区中的哪一区中进行分配。  
（3）类型标志组合了行为修饰符和区修饰符，将各种可能用到的组合归纳为不同类型，简化了修饰符的使用。  
**行为修饰符**：部分api，详情见p192
```
__GFP_WAIT                                                                                       分配器可以睡眠
__GFP_HIGH                                                                                      分配器可以访问紧急事件缓冲池
__GFP_IO                                                                                            分配器可以启动磁盘IO
.....
```
**区修饰符**  
api：
```
__GFP_DMA                                                                                        从ZONE_DMA分配
__GFP_DMA32                                                                                   从ZONE_DMA32分配
__GFP_HIGHMEM                                                                             从ZONE_HIGHMEM或ZONE_NORMAL分配
```
**类型标志**  
详情api见P194
## kfree()  
调用kfree来释放kmalloc()开辟的内存。
```
void kfree(const void *ptr)
```
## vmalloc()  
功能：分配的内存虚拟地址是连续的，但是物理地址不是连续的。就是malloc()一样。下面给出api
```
void * vmalloc(unsigned long size);
void vfree(const void *addr);
```
## slab层  
slab的意义：扮演了通用数据结构缓存层的角色。  
**设计思想**：  
（1）频繁使用的数据结构也会频繁分配和释放，因此应当缓存他们。  
（2）频繁分配和回收必然会导致内部碎片（难以找到大块连续的可用内存）。为了避免这种现象，空闲链表的缓存会连续的存放。因为已释放的数据结构又会放回空闲链表，因此不会导致碎片。  
（3）回收的对象可以立即投入下一次分配，因此，对于频繁的分配和释放，空闲链表能够提高其性能。  
（4）如果分配器知道对象大小，页大小和总的告诉缓存的大小这样的概念，它会做出更明智的角色。  
（5）如果让部分缓存专属单个处理器，那么分配和释放就可以在不加smp锁的情况下进行。  
（6）如果分配器是numa相关的，他就可以从相同的内存节点为请求者进行分配。  
（7）对存放的对象进行着色，以防止多个对象映射到相同的告诉缓存行。  
## slab层设计  
slab层把不同的对象划分为所谓高速缓存组，其中每个高速缓存组都存放不同类型的对象。**每种对象类型对应一个高速缓存。比如一个高速缓存用于存放进程描述符**。  
**slab&高速缓存&页之间关系**：一个高速缓存被划分成多个slab，一个slab由一个或多个连续物理页组成。（一般情况下仅仅由一页组成）。    
每个slab都包含一些对象成员，这里的对象指的是被缓存的数据结构。每个slab处于三种状态之一：满、部分满、空。
```
struct slab{
        struct list_head        list;                                   //满、部分满、空链表
        unsigned long           colouroff;                      //slab着色偏移量
        void                               *s_mem;                      //在slab中的第一个对象
        unsigned int               inuse;                               //slab中已分配的对象数
        kmem_bufctl_t           free;                                //第一个空闲对象
};
```
