## 杂项  
（1）程序运行起来的虚拟地址都是从1开始的。只不过每个程序维护的页表不一样。所以他们映射的物理内存也不一样。  
（2）dll动态加载，用时才加载到内存。  
（3）对于虚拟地址上的堆，也是连续的。那么不停的new，delete就会产生内存碎片。那么申请固定内存，就显得额外重要。  
（4）外部碎片：比如在堆上， 不断的申请释放，就会出现小夹缝。导致这块小夹缝谁都用不了，因为太小了。这就叫外部碎片。  
（5）内部碎片：我申请了3k内存，给我了4k，我申请了4k内存，给了我4k。我申请了4k+1内存，给了我8k。给的我多余的内存就叫做内部碎片。  
（6）逻辑地址的不连续：因为在逻辑地址上，又给你划分了许多段，有的段存代码段，有的段作为栈，有的段作为堆。有的段什么也不做，什么也不做的段如果被访问到了。那么就会出现段错误。  
（7）物理页面要和逻辑页面保持一致。  
（8）逻辑地址的寻址：假如，你的**逻辑地址为32位，页大小为4k（代表有2^12个页表项，也就是真正存放物理内存地址的地方）**。假如我有一个逻辑地址为：  
00000000 00000000 00000000 00000110这样一个为6的逻辑地址。首先后**12个位也就是00 00000110，代表第几个页表项**。而前**20个位代表第几个逻辑页表，有了逻辑页表，再通过一个哈希表（页表）对应出第几个物理页表**。最后将**物理页表与逻辑页表进行拼接，得到真正的物理地址**。  
（9）
## 页  
**介绍**：内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字节，但是，内存管理单元（MMU，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，MMU以页大小为单位来管理系统中的页表。从虚拟内存的角度来看，页就是最小单位。    
内核用struct page结构来标识系统中的每个物理页。
```
struct page{
        unsigned long                   flags;
        atomic_t                              _count;
        atomic_t                              _mapcount;
        unsigned long                   private;
        struct address_space     *mapping;
        pgoff_t                                   index;
        struct list_head                  lru;
        void                                          *virtual;
};
```
**属性解释**：  
flag：用来存放页的状态。状态包括页是不是脏的，是不是被锁在内存中等等。  
count：存放页的引用计数-------也就是这一页被引用了多少此。当引用计数变为-1时，就说明当前内核并没有引用这一页。但是内核代码不应该直接检查该域。应该调用page_count()函数来进行检查。该函数唯一参数就是page结构。**当页空闲时，尽管该结构内部的count值是负数，但是对page_count()函数而言，返回0标示页空闲，返回一个正整数表示页在使用**。    
virtual：是页的虚拟地址。通常情况下他就是页在虚拟内存中的地址。有些内存（即所谓的高端内存）并不永久的映射到内核地址空间上。  
## 区  
由于硬件的限制，内核并不能对所有的页一视同仁。有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区。linux必须处理如下两种由于硬件存在缺陷而引起的内存寻址问题。  
一些硬件只能用于某些特定的内存地址来执行DMA（直接内存访问）。  
一些体系结构的内存的物理寻址范围比虚拟寻址范围大的多。这样，就有一些内存不能永久的映射到内核空间上。  
因为这个条件，linux主要包含了四种区：  
ZONE_DMA：这个区包含的页能用来执行DMA操作。  
ZONE_DMA32：和ZONE_DMA类似，该区包含的页面可用来执行DMA操作。而和ZONE_DMA不同之处在于，这些页面只能被32位设备访问。






