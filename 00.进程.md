# 进程管理  
## 进程的的定义  
进程就是处于执行期的程序以及相关的资源的总称。  
## 进程描述符及任务结构  
内核把进程的列表存放在叫做任务队列的**双向循环链表**中。链表中的每一项都是**类型为task_struct**，称为**进程描述符**的结构，该结构定义在<linux/sched.h>文件，
进程描述符中包含了一个具体进程的所有信息。  
task_struct相对较大，在32位机器上，它大约有1.7kb，大概有这也的信息：它打开的文件，进程的地址空间，挂起的信号，进程的状态.....等。  
## 分配进程描述符  
Linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色的目的（注：slab暂不理解，需要学习）  
用slab分配器动态生成task_struct，所以只需在栈底（对于向下增加的栈来说）或栈顶（对于向上增长的栈来说）创建一个新的结构struct thread_info。  
在x86上，struct thread_info 在文件 <asm/thread_info.h>中定义如下：
```
struct thread_info{
        struct task_struct            *task;
        struct exec_domain      *exec_domain;  
        __u32                                   flags;
        __u32                                   cpu;
        __u32                                   status;
        int                                          preempt_count;
        mm_segment_t               addr_limit;
        struct restart_block        restart_block;
        void                                        *sysenter_return;
        int                                            uaccess_err;
};
```
## 进程描述符的存放  
内核通过一个唯一的进程标识值或PID来标识每个进程。PID是一个short int的类型。最大值为32768。如果需要可以通过修改proc/sys/kernel/pid_max来提高上限。  
在内核中，访问任务通常需要获得指向其task_struct的指针。实际上，内核中大部分处理进程的代码都是直接通过task_struct进行的。那么如何寻址呢。通过thread_info结构  
体中的task_struct指针来拿到地址。那么如何快速thread_struct的地址来访问的它的变量呢。需要通过current_thread_info()->task来得到。大致原理就是偏移一个栈的大小  
来直接获取到这个thread_struct的地址。
