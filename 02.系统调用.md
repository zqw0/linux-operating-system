# 系统调用  
## 系统调用的作用  
（1）它为用户空间提供了一种硬件的抽象接口。（方便用户对一些资源进行操作）  
（2）系统调用保证了系统的稳定和安全。（防止用户不正确的使用硬盘等设备，造成破坏）  
（3）每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共借口，也是出于这样的考虑。（不太理解）  
## API、POSIX和C库
**API和系统调用的关系：**一个API定义了一组应用程序使用的编程接口。他们可以实现成一个系统调用，也可以通过调用多个系统调用 来实现，而完全不使用任何系统调用也可以。  
## 系统调用一些名词解释  
**asmlinkage**：放在函数的最前面，这是一个编译指令，通知编译器仅从栈中提取该函数的参数。所有系统调用都需要这个限定词。（eg：asmlinkage long sys_getpid(void)）  
**系统调用号**：在Linux中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就用来指明到底是要执行哪个系统调用。**进程不会提及系统调用的名称**。**特点**：一旦分配就不在允许更改。一旦失效就永久作废，不允许回收再利用。   
## 调用与实现系统调用  
（1）**调用系统调用**：通过引发一个**软中断异常**来促使系统切换到内核态去执行异常处理程序。**此时的异常处理程序就是系统调用处理程序**。在x86系统上预定义的**软中断是中断号128，通过int $0x80指令触发该中断**。  
（2）**实现系统调用的参数验证**：  
1.**检查用户提供的指针是否有效**。内核必须保证：  
指针指向的内存区域属于用户空间。进程决不能哄骗内核去读内核空间的数据。  
指针指向的内存区域在进程的地址空间里。进程决不能哄骗内核去读其他进程的数据。  
如果是读，该内存应被表记为可读，如果是写，该内存应被表记为可写，如果是可执行，该内存应该被标记为可执行。进程决不能绕过内存访问限制。
**内核提供了两个方法来完成必须的检查和内核空间与用户空间之间数据的来回拷贝。copy_to_user()、copy_from_user()**
2.**检查指针是否合法有效**  
调用者可以使用capable()函数来检查是否有权能对指定的资源进行操作，如果它返回非0，调用者就有权进行操作，如果它返回0则无权操作。（比如重启指令，不能让任何进程都可以使用此系统调用）   
## 绑定一个系统调用的最后步骤  
将它注册成一个正式的系统调用。详情见书65页。不在叙述。
