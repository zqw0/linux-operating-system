# 内核同步方法  
## 原子操作  
原子操作是其他同步方法中的基石。原子操作可以保证指令以原子的方式执行-----执行过程不被打断。  
## 原子整数操作  
结构声明：
```
typedef struct{
        volatile int counter;
} atomic_t;

typedef struct{
        volatile long counter;
} atomic64_t;
```
简单使用举例：
```
automic_t v;
automic_t u = ATOMIC_INIT(0);
automic_set(&v, 4);//v=4;
automic_add(2,&v);//v+=2;
automic_inc(&v);//v++;
```
给出部分api使用说明。详细api在p143页。
```
ATOMIC_INIT(int i)            在声明一个automic_t 变量时，初始化为i；
int atomic_read(atomic_t *v)          原子读取整数变量v
void atomic_set(atomic_t *v, int i)   原子设置v的值为i
void atomic_add(int i, atomic_t *v) 原子的给v的值+i
void atomic_sub(int i, atomic_t *v) 原子的给v的值-i
void atomic_inc(atomic_t *v)原子的给v的值-1
....
```
## 自旋锁  
定义：简称忙等待，不断询问这个锁有没有打开，来获取这个锁。  
api：p150。  
另外，在进程持有此锁的情况下，不参加调度。也不允许在加锁的期间睡眠。  
## 信号量  
**特性**：  
（1）：由于争用信号量的进程，正在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。    
（2）：相反，锁被短时间持有时，使用信号量就不太适宜了。因为睡眠，维护队列以及唤醒所花费的开销可能比锁占用的全部时间还要长。  
（3）：由于执行线程在锁被争用时会睡眠，所以只能在进程上下文才能获取信号量锁，因为在中断上下文是不能进行调度的。  
（4）：你可以在持有信号量时去睡眠，因为当其他进程试图获得同一信号量时不会因此而死锁。  
（5）：在你占用信号量的同时，不能占用自旋锁。因为在你等待信号量时可能会睡眠，而在持有自旋锁时是不允许睡眠的。  
### 计数信号量和二值信号量  
**使用者数量**：信号量同时允许的持有者数量可以在声明信号量时指定。  
**二值信号量**：在一个时刻仅允许有一个锁的持有者。使用者数量 = 1。  
**计数信号量**：初始化时，将数量设置为大于1的非0值。使用者数量 > 1。  
如果down之后为负数，则放入等待队列中。如果>=0。则允许进入临界区。  
**信号量使用api**：p155。  
## 互斥锁  
**定义**为：可以睡眠的自旋锁。  
**特性**：  
（1）：任何时刻中只有一个任务可以持有mutex，也就是说，mutex的使用计数永远是1。  
（2）：给mutex上锁者必须负责给其再解锁。  
（3）：不允许地柜上锁和解锁。  
（4）：当持有一个mutex时，进程不允许退出。  
（5）：mutex只能通过官方api处理。不允许自己手动复制。    
## 顺序锁  
**思想**：主要一个序列计数器。当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都被读取。如果读取的序列号值相同，说明在读操作进行的过程中没有被写操作打断过。此外，如果读取的值是偶数，那么就表明写操作没有发生。（因为锁的初始值是0，写锁会使值变成奇数，释放的时候变成偶数）。    





